#!/usr/bin/ksh

# iterative coupling stuff

jsbach_prepare_forcing()
{
        if [[ "x${iterative_coupling}" == "x1" ]]; then
                if [ -f "${CONFIG_DIR_jsbach}/jsbach_init_override.dat" ]; then
                        echo "PG: Sourcing ${CONFIG_DIR_jsbach}/jsbach_init_override.dat" 
                        cat ${CONFIG_DIR_jsbach}/jsbach_init_override.dat
                        source ${CONFIG_DIR_jsbach}/jsbach_init_override.dat
                fi
        fi
}

        if [[ "x$iterative_coupling" == "x1" ]]; then
                # Check if: first run, first chunk, or chunk number isn't set yet"
                if [[ "x${RUN_NUMBER_jsbach}" == "x1" ]] || [[ "x${CHUNK_NUMBER_jsbach}" == "x1" ]] || [[ "x${CHUNK_NUMBER_jsbach}" == "x" ]]; then
                        mecho "PG: No updates in first run!"
                else
                        echo "                  Sourcing: ${CONFIG_DIR_jsbach}/jsbach_namelist_switches_${CHUNK_START_DATE_jsbach}-${CHUNK_END_DATE_jsbach}.dat"
                        source ${CONFIG_DIR_jsbach}/jsbach_namelist_switches_${CHUNK_START_DATE_jsbach}-${CHUNK_END_DATE_jsbach}.dat
                        echo "                  done, the following was sourced:"
                        cat ${CONFIG_DIR_jsbach}/jsbach_namelist_switches_${CHUNK_START_DATE_jsbach}-${CHUNK_END_DATE_jsbach}.dat
                fi
        fi







# AWICM

jsbach_set_defaults()
{
	if [[ "x${ADJUST_TO_FESOM_GRID_jsbach}" = "x1" ]]; then
		jsbach_nc=""
	fi
}

jsbach_set_directory_paths()
{
	jsbach_INPUT_DIR=${jsbach_INPUT_DIR:-${POOL_DIR_jsbach}/JSBACH/input/${jsbach_DATASET}}

	if [[ "x${ADJUST_TO_FESOM_GRID_jsbach}" = "x1" ]]; then
		test_if_set RES_fesom
		ADJ_INPUT_DIR_jsbach=${MESH_DIR_fesom}/tarfiles${RES_jsbach}/input
		ADJ_INPUT_DIR_jsbach=${ADJ_INPUT_DIR_jsbach}/jsbach
		OCERES_jsbach=${OCERES_jsbach:-${RES_fesom}}
	else
		ADJ_INPUT_DIR_jsbach=${jsbach_INPUT_DIR}/${RES_jsbach}
		OCERES_jsbach=${OCERES_jsbach:-${RES_mpiom}}
	fi
}

jsbach_modify_config()
{
	if [[ "x${ADJUST_TO_FESOM_GRID_jsbach}" = "x1" ]]
	then
		general_remove_namelist_value namelist.jsbach hydrology_ctl gethd	
		general_remove_namelist_value namelist.jsbach hydrology_ctl puthd	
	fi

}


# MPIESM

jsbach_prepare_init()
{
	case $setup_name in
		mpiesm )
			case $echam_VERSION in 
				6.3.02p4 )
					LCTLIBDEF_jsbach=${LCTLIBDEF_jsbach:-${MODEL_DIR_mpiesm}/util/running/adjunct_files/jsbach/lctlib_nlct21.def}
					;;
				6.3.04p1 )
					LCTLIBDEF_jsbach=${LCTLIBDEF_jsbach:-${MODEL_DIR_mpiesm}/util/running/adjunct_files/jsbach/lctlib_nlct21.def}
					;;
			esac
			;;
	esac
}













jsbach_modify_forcing()
{
			case $SCENARIO_jsbach in
				PALEO | 1850 | PI-CTRL* | 4CO2 | 1percCO2 | SCEN | HIST)
					for((yr = YR0_jsbach + -2; yr <= YRN_jsbach + 0; ++yr)) 
					do
						echo "		jsbach: Setting year to $yr in forcing file Ndepo.${yr}.nc"
            					cdo setyear,${yr} ${FORCING_DIR_jsbach}/Ndepo.${yr}.nc ${FORCING_DIR_jsbach}/foo${yr}.nc >> $dumpfile 2>&1
            					mv ${FORCING_DIR_jsbach}/foo${yr}.nc ${FORCING_DIR_jsbach}/Ndepo.${yr}.nc >> $dumpfile
					done
                    ;;
	esac
}


jsbach_prepare_restart_in()
{
	found=0
	if stat --printf='' ${INI_RESTART_DIR_jsbach_protect}/restart_${PARENT_EXP_ID_jsbach}_*_${PARENT_DATE_jsbach}.nc 2>/dev/null; then
		found=1
 		files=`ls ${INI_RESTART_DIR_jsbach_protect}/restart_${PARENT_EXP_ID_jsbach}_*_${PARENT_DATE_jsbach}.nc`
		substream_finder='`echo $file | rev | cut -d_ -f2 | rev`'
	elif stat --printf='' ${INI_RESTART_DIR_jsbach_protect}/restart_${PARENT_EXP_ID_jsbach}_${PARENT_DATE_jsbach}_*.nc 2>/dev/null; then
		found=1
		files=`ls ${INI_RESTART_DIR_jsbach_protect}/restart_${PARENT_EXP_ID_jsbach}_${PARENT_DATE_jsbach}_*.nc`
		substream_finder='`echo $file | rev | cut -d_ -f1 | cut -d. -f2 | rev`'
	fi

	if [[ "x${found}" = "x1" ]]; then
		echo "		Taking first jsbach restart data from INI_RESTART_DIR_jsbach=${INI_RESTART_DIR_jsbach_protect}"
	fi

        for file in $files
        do
                eval substream=${substream_finder}
		case $substream in 
			yasso | jsbid | jsbach | surf | nitro | veg | land ) 
				add_to $file restart_${EXP_ID}_${substream}.nc $WF_jsbach
				;;
			* )
				;;
		esac
	done
}

jsbach_prepare_config()
{
	if [[ ${jsbach_VERSION} = "3.20" ]]; then
		jsbach_NAMELIST_DIR=${jsbach_NAMELIST_DIR:-${FUNCTION_PATH}/../../namelists/jsbach/${jsbach_VERSION}/${SCENARIO_jsbach}/${DYNVEG_jsbach}}
	else
		jsbach_NAMELIST_DIR=${jsbach_NAMELIST_DIR:-${FUNCTION_PATH}/../../namelists/jsbach/${jsbach_VERSION}/${SCENARIO_jsbach}/${RES_jsbach}}
	fi

	if [[ -r ${jsbach_NAMELIST_DIR}/namelist.jsbach ]]; then	
		if [[ "x${RUN_NUMBER_jsbach}" = "x1" ]]; then
			echo "		Taking jsbach namelist from jsbach_NAMELIST_DIR=${jsbach_NAMELIST_DIR}"
		fi
		add_to ${jsbach_NAMELIST_DIR}/namelist.jsbach namelist.jsbach
	else
		mecho "Unknown scenario or scenario not set. Please choose out of HIST, SCEN, PI-CTRL, RCP* and PALEO"
		mecho "and change values according to your needs."
		mecho "namelist.jsbach for ${DYNVEG_jsbach} not found in namelists/jsbach/${jsbach_VERSION}."
		exit 42
	fi
}


jsbach_cleanup()
{
	mecho "storing of ${srfmod} data started"
	echo "			storing of ${srfmod} data started"

	cd ${WORK_DIR}
	if files=$(double_loop  ${EXP_ID}_SUBSTREAM2.01_SUBSTREAM1); then
		while read -r file substream ym; do
			echo working on $file $substream $ym
			case $substream in 
				yasso | jsbach | jsbid | surf | nitro | veg | land | hd) 
					mv ${file} ${EXP_ID}_${srfmod}_${substream}_${ym}.grb >> $dumpfile 2>&1
					add_to ${WORK_DIR}/${EXP_ID}_${srfmod}_${substream}_${ym}.grb ${EXP_ID}_${srfmod}_${substream}_${ym}.grb output
					add_to ${WORK_DIR}/${EXP_ID}_${ym}.01_${substream}.codes ${EXP_ID}_${srfmod}_${substream}.codes output
					;;
				* )
					;;
			esac
		done <<< $files
	fi
	if files=$(double_loop  ${EXP_ID}_SUBSTREAM2.01_SUBSTREAM1.nc); then
		while read -r file substream ym; do
			echo working on $file $substream $ym
			case $substream in 
				yasso | jsbach | jsbid | surf | nitro | veg | land | hd) 
					mv ${file} ${EXP_ID}_${srfmod}_${substream}_${ym}.nc >> $dumpfile 2>&1
					add_to ${WORK_DIR}/${EXP_ID}_${srfmod}_${substream}_${ym}.nc ${EXP_ID}_${srfmod}_${substream}_${ym}.nc output
					;;
				* )
					;;
			esac
		done <<< $files
	fi
	
	if files=$(double_loop  restart_${EXP_ID}_SUBSTREAM2_SUBSTREAM1.nc); then
		while read -r file substream date; do
			echo working on $file $substream $date
			case $substream in 
				yasso | jsbach | jsbid | surf | nitro | veg | land | hd) 
					rdate=$(${FUNCTION_PATH}/format_date  -f6 -- ${date} | cut -f1 -d_)
					mv ${file} restart_${EXP_ID}_${substream}_${rdate}.nc >> $dumpfile 2>&1
					if [[ "x$rdate" = "x$END_DATE_jsbach" ]]; then
						add_to ${WORK_DIR}/restart_${EXP_ID}_${substream}_${rdate}.nc \
							restart_${EXP_ID}_${substream}.nc restart_out
					else
						add_to ${WORK_DIR}/restart_${EXP_ID}_${substream}_${rdate}.nc \
							restart_${EXP_ID}_${substream}_${rdate}.nc restart_out
					fi 
					;;
				* )
					;;
			esac
		done <<< $files
	fi

	cd $SCRIPT_DIR
	mecho "storing of ${srfmod} data finished"
	echo "			storing of ${srfmod} data finished"
}


















jsbach_post_process()
{
	cd $POST_DIR
	mecho 'jsbach post-processing started'

	if files=$(double_loop ${EXP_ID}_jsbach_SUBSTREAM1_SUBSTREAM2.grb); then
		while read -r file stream ym; do
			for meantag in $MEANTAGS_jsbach; do	
        			while (( $(jobs -p | wc -l) >=  max_jobs )); do sleep $sleep_time; done
				call_if_exists jsbach_post_process_${meantag}
			done
		done <<< $files
	fi
	if files=$(double_loop ${EXP_ID}_jsbach_SUBSTREAM1_SUBSTREAM2.nc); then
		while read -r file stream ym; do
			for meantag in $MEANTAGS_jsbach; do	
        			while (( $(jobs -p | wc -l) >=  max_jobs )); do sleep $sleep_time; done
				call_if_exists jsbach_post_process_${meantag}
			done
		done <<< $files
	fi

	CONCATENATE_POST_PROCESS_jsbach=${CONCATENATE_POST_PROCESS_jsbach:-0}

	if [[ "x${CONCATENATE_POST_PROCESS_jsbach}" = "x1" ]]; then

		mecho 'JSBACH concatenation started'
		for meantag in $MEANTAGS_jsbach; do
			case $meantag in 
				BOT | ATM | LOG | co2 | QBO | tracer )
					if files=$(ls ${EXP_ID}_jsbach_${meantag}_mm_*.nc); then
        					output=${EXP_ID}_jsbach_${meantag}_${startdate}-${enddate}.nc
            					time_merge $output $files
						add_to ${POST_DIR}/$output $output output
					fi
					;;
				mm | dm | ym )
					if files=$(double_loop ${meantag}_jsbach_SUBSTREAM1_SUBSTREAM2.nc); then
					newstream=0
					thesefiles="NONE"
					while read -r file stream ym; do
						if ! [[ "x$stream" = "x$laststream" ]]; then
							if ! [[ "x${thesefiles}" = "xNONE" ]]; then
								output=${meantag}_jsbach_${laststream}_${startdate}-${enddate}.nc
								time_merge $output $thesefiles
								add_to ${POST_DIR}/$output $output output
							fi
							thesefiles=$file
						else
							thesefiles="$thesefiles $file"
						fi
						laststream=$stream
					done <<< $files
					fi
					;;
			esac
		done
	fi

	TAR_RAW_OUTPUT_jsbach=${TAR_RAW_OUTPUT_jsbach:-0}
	TAR_FREQ=${TAR_FREQ:-1}

	mod=$(( RUN_NUMBER_jsbach % TAR_FREQ ))
	if [[ "$mod" = "0" ]]; then
		TAR_RAW_OUTPUT_jsbach=${TAR_RAW_OUTPUT_jsbach:-1}
	else
		TAR_RAW_OUTPUT_jsbach=${TAR_RAW_OUTPUT_jsbach:-0}
	fi

	if [[ "x${TAR_RAW_OUTPUT_jsbach}" = "x1" ]]; then
		cd ${RESTART_DIR_jsbach}
		if ! [[ -e ${EXP_ID}_jsbach_raw_restarts_${END_DATE_jsbach}.tar.gz ]]; then
			# --use-compress-program=pigz -cvf 
			tar --create $tar_compress_program ${TAR_DIR}/${EXP_ID}_jsbach_raw_restarts_${END_DATE_jsbach}.tar.gz restart_${EXP_ID}_*_${END_DATE_jsbach}.nc
		else
			tar --append $tar_compress_program ${TAR_DIR}/${EXP_ID}_jsbach_raw_restarts_${END_DATE_jsbach}.tar.gz restart_${EXP_ID}_*_${END_DATE_jsbach}.nc
		fi
		cd ${DATA_DIR_jsbach}
		if ! [[ -e ${EXP_ID}_jsbach_raw_output_${END_DATE_jsbach}.tar.gz ]]; then
			# --use-compress-program=pigz -cvf 
			tar --create $tar_compress_program ${TAR_DIR}/${EXP_ID}_jsbach_raw_output_${END_DATE_jsbach}.tar.gz ${EXP_ID}_jsbach_*_${END_DATE_jsbach}.nc
		else
			tar --append $tar_compress_program ${TAR_DIR}/${EXP_ID}_jsbach_raw_output_${END_DATE_echam}.tar.gz ${EXP_ID}_jsbach_*_${END_DATE_jsbach}.nc
		fi
	fi

	ARCHIVE_TAR_OUTPUT_jsbach=${ARCHIVE_TAR_OUTPUT_jsbach:-0}

	if [[ "x${ARCHIVE_TAR_OUTPUT_jsbach}" = "x1" ]]; then
		if [[ "x${TAR_RAW_OUTPUT_jsbach}" = "x1" ]]; then
			call_if_exists $archive_tars "${TAR_DIR}/\*.tar.gz"
		fi
	fi
	cd $SCRIPT_DIR
}

jsbach_after_last_run_in_chunk() {
        mecho "Nothing to do..." 
}
